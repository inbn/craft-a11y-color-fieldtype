{"version":3,"sources":["A11ycolor.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","process","__filename","requireFn","makeRequire","stringRequire","defineCache","loaderCache","alreadyCalled","path","normalize","name","baseName","baseParts","charAt","ary","part","splice","trimDots","split","slice","concat","join","runFactory","id","deps","factory","m","result","uri","map","depName","undefined","apply","define","Array","isArray","systemRequire","relId","amdRequire","callback","nextTick","toUrl","filePath","indexOf","dirname","filename","arguments","prefix","plugin","relName","index","originalId","substring","load","value","fromText","text","makeLoad","hasOwnProperty","amd","this","_process","2","ColorContrastChecker","prototype","fontSize","rgbClass","toString","g","b","isValidSixDigitColorCode","hex","test","isValidThreeDigitColorCode","isValidColorCode","convertColorToSixDigit","hexToLuminance","color","getRGBFromHex","LRGB","calculateLRGB","calculateLuminance","check","colorA","colorB","l1","l2","contrastRatio","getContrastRatio","verifyContrastRatio","checkPairs","pairs","results","pair","push","lRGB","isLevelAA","WCAG_AA","isLevelAAA","WCAG_AAA","rVal","gVal","bVal","rgb","Object","create","parseInt","calculateSRGB","key","sRGB","parseFloat","val","Math","pow","lumA","lumB","lighter","darker","ratio","amdefine","3","normalizeArray","parts","allowAboveRoot","up","last","unshift","filter","xs","res","resolve","resolvedPath","resolvedAbsolute","cwd","TypeError","isAbsolute","trailingSlash","substr","paths","relative","from","to","trim","arr","start","end","fromParts","toParts","min","samePartsLength","outputParts","sep","delimiter","charCodeAt","hasRoot","matchedSlash","basename","ext","extname","startDot","startPart","preDotState","str","len","4","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","args","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","dir","umask","5","$","window","document","pluginName","defaults","Plugin","element","options","extend","_defaults","_name","init","_this","colorContrastChecker","$colorFieldContainer","$colorField","find","proxy","updateColorContrast","event","contrastColor","fieldColor","currentTarget","console","log","fn","each","data","jQuery","color-contrast-checker"],"mappings":"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","file":"A11ycolor.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n(function (process,__filename){\n/** vim: et:ts=4:sw=4:sts=4\n * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/amdefine for details\n */\n\n/*jslint node: true */\n/*global module, process */\n'use strict';\n\n/**\n * Creates a define for node.\n * @param {Object} module the \"module\" object that is defined by Node for the\n * current module.\n * @param {Function} [requireFn]. Node's require function for the current module.\n * It only needs to be passed in Node versions before 0.5, when module.require\n * did not exist.\n * @returns {Function} a define function that is usable for the current node\n * module.\n */\nfunction amdefine(module, requireFn) {\n    'use strict';\n    var defineCache = {},\n        loaderCache = {},\n        alreadyCalled = false,\n        path = require('path'),\n        makeRequire, stringRequire;\n\n    /**\n     * Trims the . and .. from an array of path segments.\n     * It will keep a leading path segment if a .. will become\n     * the first path segment, to help with module name lookups,\n     * which act like paths, but can be remapped. But the end result,\n     * all paths that use this function should look normalized.\n     * NOTE: this method MODIFIES the input array.\n     * @param {Array} ary the array of path segments.\n     */\n    function trimDots(ary) {\n        var i, part;\n        for (i = 0; ary[i]; i+= 1) {\n            part = ary[i];\n            if (part === '.') {\n                ary.splice(i, 1);\n                i -= 1;\n            } else if (part === '..') {\n                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                    //End of the line. Keep at least one non-dot\n                    //path segment at the front so it can be mapped\n                    //correctly to disk. Otherwise, there is likely\n                    //no path mapping for a path starting with '..'.\n                    //This can still fail, but catches the most reasonable\n                    //uses of ..\n                    break;\n                } else if (i > 0) {\n                    ary.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n        }\n    }\n\n    function normalize(name, baseName) {\n        var baseParts;\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === '.') {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                baseParts = baseName.split('/');\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                baseParts = baseParts.concat(name.split('/'));\n                trimDots(baseParts);\n                name = baseParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    /**\n     * Create the normalize() function passed to a loader plugin's\n     * normalize method.\n     */\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(id) {\n        function load(value) {\n            loaderCache[id] = value;\n        }\n\n        load.fromText = function (id, text) {\n            //This one is difficult because the text can/probably uses\n            //define, and any relative paths and requires should be relative\n            //to that id was it would be found on disk. But this would require\n            //bootstrapping a module/require fairly deeply from node core.\n            //Not sure how best to go about that yet.\n            throw new Error('amdefine does not implement load.fromText');\n        };\n\n        return load;\n    }\n\n    makeRequire = function (systemRequire, exports, module, relId) {\n        function amdRequire(deps, callback) {\n            if (typeof deps === 'string') {\n                //Synchronous, single module require('')\n                return stringRequire(systemRequire, exports, module, deps, relId);\n            } else {\n                //Array of dependencies with a callback.\n\n                //Convert the dependencies to modules.\n                deps = deps.map(function (depName) {\n                    return stringRequire(systemRequire, exports, module, depName, relId);\n                });\n\n                //Wait for next tick to call back the require call.\n                if (callback) {\n                    process.nextTick(function () {\n                        callback.apply(null, deps);\n                    });\n                }\n            }\n        }\n\n        amdRequire.toUrl = function (filePath) {\n            if (filePath.indexOf('.') === 0) {\n                return normalize(filePath, path.dirname(module.filename));\n            } else {\n                return filePath;\n            }\n        };\n\n        return amdRequire;\n    };\n\n    //Favor explicit value, passed in if the module wants to support Node 0.4.\n    requireFn = requireFn || function req() {\n        return module.require.apply(module, arguments);\n    };\n\n    function runFactory(id, deps, factory) {\n        var r, e, m, result;\n\n        if (id) {\n            e = loaderCache[id] = {};\n            m = {\n                id: id,\n                uri: __filename,\n                exports: e\n            };\n            r = makeRequire(requireFn, e, m, id);\n        } else {\n            //Only support one define call per file\n            if (alreadyCalled) {\n                throw new Error('amdefine with no module ID cannot be called more than once per file.');\n            }\n            alreadyCalled = true;\n\n            //Use the real variables from node\n            //Use module.exports for exports, since\n            //the exports in here is amdefine exports.\n            e = module.exports;\n            m = module;\n            r = makeRequire(requireFn, e, m, module.id);\n        }\n\n        //If there are dependencies, they are strings, so need\n        //to convert them to dependency values.\n        if (deps) {\n            deps = deps.map(function (depName) {\n                return r(depName);\n            });\n        }\n\n        //Call the factory with the right dependencies.\n        if (typeof factory === 'function') {\n            result = factory.apply(m.exports, deps);\n        } else {\n            result = factory;\n        }\n\n        if (result !== undefined) {\n            m.exports = result;\n            if (id) {\n                loaderCache[id] = m.exports;\n            }\n        }\n    }\n\n    stringRequire = function (systemRequire, exports, module, id, relId) {\n        //Split the ID by a ! so that\n        var index = id.indexOf('!'),\n            originalId = id,\n            prefix, plugin;\n\n        if (index === -1) {\n            id = normalize(id, relId);\n\n            //Straight module lookup. If it is one of the special dependencies,\n            //deal with it, otherwise, delegate to node.\n            if (id === 'require') {\n                return makeRequire(systemRequire, exports, module, relId);\n            } else if (id === 'exports') {\n                return exports;\n            } else if (id === 'module') {\n                return module;\n            } else if (loaderCache.hasOwnProperty(id)) {\n                return loaderCache[id];\n            } else if (defineCache[id]) {\n                runFactory.apply(null, defineCache[id]);\n                return loaderCache[id];\n            } else {\n                if(systemRequire) {\n                    return systemRequire(originalId);\n                } else {\n                    throw new Error('No module with ID: ' + id);\n                }\n            }\n        } else {\n            //There is a plugin in play.\n            prefix = id.substring(0, index);\n            id = id.substring(index + 1, id.length);\n\n            plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n\n            if (plugin.normalize) {\n                id = plugin.normalize(id, makeNormalize(relId));\n            } else {\n                //Normalize the ID normally.\n                id = normalize(id, relId);\n            }\n\n            if (loaderCache[id]) {\n                return loaderCache[id];\n            } else {\n                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n\n                return loaderCache[id];\n            }\n        }\n    };\n\n    //Create a define function specific to the module asking for amdefine.\n    function define(id, deps, factory) {\n        if (Array.isArray(id)) {\n            factory = deps;\n            deps = id;\n            id = undefined;\n        } else if (typeof id !== 'string') {\n            factory = id;\n            id = deps = undefined;\n        }\n\n        if (deps && !Array.isArray(deps)) {\n            factory = deps;\n            deps = undefined;\n        }\n\n        if (!deps) {\n            deps = ['require', 'exports', 'module'];\n        }\n\n        //Set up properties for this module. If an ID, then use\n        //internal cache. If no ID, then use the external variables\n        //for this node module.\n        if (id) {\n            //Put the module in deep freeze until there is a\n            //require call for it.\n            defineCache[id] = [id, deps, factory];\n        } else {\n            runFactory(id, deps, factory);\n        }\n    }\n\n    //define.require, which has access to all the values in the\n    //cache. Useful for AMD modules that all have IDs in the file,\n    //but need to finally export a value to node based on one of those\n    //IDs.\n    define.require = function (id) {\n        if (loaderCache[id]) {\n            return loaderCache[id];\n        }\n\n        if (defineCache[id]) {\n            runFactory.apply(null, defineCache[id]);\n            return loaderCache[id];\n        }\n    };\n\n    define.amd = {};\n\n    return define;\n}\n\nmodule.exports = amdefine;\n\n}).call(this,require('_process'),\"/node_modules/amdefine/amdefine.js\")\n\n},{\"_process\":4,\"path\":3}],2:[function(require,module,exports){\n'use strict';\n\n/**\n * Color Contast Checker\n * An accessibility checker tool for validating the color contrast based on WCAG 2.0 standard.\n * var ccc = new ColorContrastChecker();\n\n * var color1 = \"#FFFFFF\";\n * var color2 = \"#000000;\n\n * if (ccc.isLevelAA(color1, color2, 14)) {\n *     alert(\"Valid Level AA\");\n * } else {\n *     alert(\"Invalid Contrast\");\n * }\n */\n\nvar amdefine = false;\nif (typeof define !== 'function')\n    var define = require('amdefine')(module, require),\n        amdefine = true;\n\ndefine(function (require, exports, module) {\n\n    var ColorContrastChecker = function() {};\n\n    ColorContrastChecker.prototype = {\n        fontSize: 14,\n        rgbClass : {\n            toString: function() {\n                return '<r: ' + this.r +\n                    ' g: ' + this.g +\n                    ' b: ' + this.b +\n                    ' >';\n            }\n        },\n        isValidSixDigitColorCode: function (hex){\n            var regSixDigitColorcode = /^(#)?([0-9a-fA-F]{6})([0-9a-fA-F]{6})?$/;\n            return regSixDigitColorcode.test(hex);\n        },\n        isValidThreeDigitColorCode: function (hex){\n            var regThreeDigitColorcode = /^(#)?([0-9a-fA-F]{3})([0-9a-fA-F]{3})?$/;\n            return regThreeDigitColorcode.test(hex);\n        },\n        isValidColorCode : function (hex){\n            return this.isValidSixDigitColorCode(hex) || this.isValidThreeDigitColorCode(hex);\n        },\n        convertColorToSixDigit: function (hex) {\n          return '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n        },\n        hexToLuminance: function (color) {\n            if (!this.isValidColorCode(color)) {\n                throw new Error(\"Invalid Color :\" + color);\n            }\n\n            if (this.isValidThreeDigitColorCode(color)) {\n              color = this.convertColorToSixDigit(color);\n            }\n\n            color = this.getRGBFromHex(color);\n\n            var LRGB = this.calculateLRGB(color);\n\n            return this.calculateLuminance(LRGB);\n        },\n        check: function (colorA, colorB, fontSize) {\n            if (typeof fontSize !== 'undefined') {\n                this.fontSize = fontSize;\n            }\n\n            if(!colorA || !colorB) {\n                return false;\n            }\n\n            var l1 = this.hexToLuminance(colorA); /* higher value */\n            var l2 = this.hexToLuminance(colorB); /* lower value */\n            var contrastRatio = this.getContrastRatio(l1, l2);\n\n            return this.verifyContrastRatio(contrastRatio);\n        },\n        checkPairs: function (pairs) {\n            var results = [];\n\n            for (var i in pairs) {\n                var pair = pairs[i];\n                if (typeof pair.fontSize !== 'undefined') {\n                    results.push(\n                        this.check(\n                            pair.colorA,\n                            pair.colorB,\n                            pair.fontSize\n                        )\n                    );\n                } else {\n                    results.push(\n                        this.check(\n                            pair.colorA,\n                            pair.colorB\n                        )\n                    );\n                }\n            }\n            return results;\n        },\n        calculateLuminance: function(lRGB) {\n            return (0.2126 * lRGB.r) + (0.7152 * lRGB.g) + (0.0722 * lRGB.b);\n        },\n        isLevelAA : function(colorA, colorB, fontSize) {\n            var result = this.check(colorA, colorB, fontSize);\n            return result.WCAG_AA;\n        },\n        isLevelAAA : function(colorA, colorB, fontSize) {\n            var result = this.check(colorA, colorB, fontSize);\n            return result.WCAG_AAA;\n        },\n        getRGBFromHex : function(color) {\n\n            var rgb = Object.create(this.rgbClass),\n                rVal,\n                gVal,\n                bVal;\n\n            if (typeof color !== 'string') {\n                throw new Error('must use string');\n            }\n\n            rVal = parseInt(color.slice(1, 3), 16);\n            gVal = parseInt(color.slice(3, 5), 16);\n            bVal = parseInt(color.slice(5, 7), 16);\n\n            rgb.r = rVal;\n            rgb.g = gVal;\n            rgb.b = bVal;\n\n            return rgb;\n        },\n        calculateSRGB : function(rgb) {\n            var sRGB = Object.create(this.rgbClass),\n                key;\n\n            for (key in rgb) {\n                if (rgb.hasOwnProperty(key)) {\n                    sRGB[key] = parseFloat((rgb[key] / 255), 10);\n                }\n            }\n\n            return sRGB;\n        },\n        calculateLRGB: function (rgb) {\n            var sRGB = this.calculateSRGB(rgb);\n            var lRGB = Object.create(this.rgbClass),\n                key,\n                val = 0;\n\n            for (key in sRGB) {\n                if (sRGB.hasOwnProperty(key)) {\n                    val = parseFloat(sRGB[key], 10);\n                    if (val <= 0.03928) {\n                        lRGB[key] = (val / 12.92);\n                    } else {\n                        lRGB[key] = Math.pow(((val + 0.055) / 1.055), 2.4);\n                    }\n                }\n            }\n\n            return lRGB;\n        },\n        getContrastRatio : function(lumA, lumB) {\n            var ratio,\n                lighter,\n                darker;\n\n            if (lumA >= lumB) {\n                lighter = lumA;\n                darker = lumB;\n            } else {\n                lighter = lumB;\n                darker = lumA;\n            }\n\n            ratio = (lighter + 0.05) / (darker + 0.05);\n\n            return ratio;\n        },\n        verifyContrastRatio : function(ratio) {\n\n\n            var resultsClass = {\n                toString: function() {\n                    return '< WCAG-AA: ' + ((this.WCAG_AA) ? 'pass' : 'fail') +\n                        ' WCAG-AAA: ' + ((this.WCAG_AAA) ? 'pass' : 'fail') +\n                        ' >';\n                }\n            };\n            var WCAG_REQ_RATIO_AA_LG = 3.0,\n                WCAG_REQ_RATIO_AA_SM = 4.5,\n                WCAG_REQ_RATIO_AAA_LG = 4.5,\n                WCAG_REQ_RATIO_AAA_SM = 7.0,\n                WCAG_FONT_CUTOFF = 18;\n\n            var results = Object.create(resultsClass),\n                fontSize = this.fontSize || 14;\n\n            if (fontSize >= WCAG_FONT_CUTOFF) {\n                results.WCAG_AA = (ratio >= WCAG_REQ_RATIO_AA_LG);\n                results.WCAG_AAA = (ratio >= WCAG_REQ_RATIO_AAA_LG);\n            } else {\n                results.WCAG_AA = (ratio >= WCAG_REQ_RATIO_AA_SM);\n                results.WCAG_AAA = (ratio >= WCAG_REQ_RATIO_AAA_SM);\n            }\n\n            return results;\n        }\n\n    };\n\n    return ColorContrastChecker;\n});\n\n},{\"amdefine\":1}],3:[function(require,module,exports){\n(function (process){\n// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n\n},{\"_process\":4}],4:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],5:[function(require,module,exports){\n/**\n * A11y color fieldtype plugin for Craft CMS\n *\n * A11ycolor Field JS\n *\n * @author    Iain Bean\n * @copyright Copyright (c) 2018 Iain Bean\n * @link      https://iainbean.com\n * @package   A11yColorFieldtype\n * @since     1.0.0A11yColorFieldtypeA11ycolor\n */\n\nvar ColorContrastChecker = require('color-contrast-checker');\n\n(function ($, window, document, undefined) {\n  var pluginName = 'A11yColorField';\n  var defaults = {};\n\n  // Plugin constructor\n  function Plugin(element, options) {\n    this.element = element;\n\n    this.options = $.extend({}, defaults, options);\n\n    this._defaults = defaults;\n    this._name = pluginName;\n\n    this.init();\n  }\n\n  Plugin.prototype = {\n    init: function (id) {\n      var _this = this;\n\n      this.colorContrastChecker = new ColorContrastChecker();\n\n      $(function () {\n        var $colorFieldContainer = $(_this.element);\n\n        _this.$colorField = $colorFieldContainer.find('[name=\"fields[' + _this.options.id + ']\"]');\n\n        // Add event listener for input events on any input in the container:\n        // This is either the <input type=\"color\"> or the <input type=\"text\">\n        // next to it\n        $colorFieldContainer.on('input', 'input', $.proxy(_this.updateColorContrast, _this));\n      });\n    },\n\n    updateColorContrast: function (event) {\n      var contrastColor = this.options.contrastColor;\n      var fieldColor = event.currentTarget.value;\n      var fontSize = this.options.fontSize === 'large' ? 22 : 14;\n\n      // Check if this is a valid 3 or 6 character hex code\n      if (this.colorContrastChecker.isValidColorCode(fieldColor)) {\n        // Get the ratio\n        var l1 = this.colorContrastChecker.hexToLuminance(contrastColor); /* higher value */\n        var l2 = this.colorContrastChecker.hexToLuminance(fieldColor); /* lower value */\n        var contrastRatio = this.colorContrastChecker.getContrastRatio(l1, l2);\n        // Is it valid?\n        console.log(this.colorContrastChecker.check(contrastColor, fieldColor, fontSize));\n      } else {\n        console.log('Invalid Hex');\n      }\n    }\n  };\n\n  // A really lightweight plugin wrapper around the constructor,\n  // preventing against multiple instantiations\n  $.fn[pluginName] = function (options) {\n    return this.each(function () {\n      if (!$.data(this, 'plugin_' + pluginName)) {\n        $.data(this, 'plugin_' + pluginName, new Plugin(this, options));\n      }\n    });\n  };\n})(jQuery, window, document);\n\n},{\"color-contrast-checker\":2}]},{},[5])\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYW1kZWZpbmUvYW1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udHJhc3QtY2hlY2tlci9zcmMvY29sb3ItY29udHJhc3QtY2hlY2tlci5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwic3JjL2Fzc2V0YnVuZGxlcy9hMTF5Y29sb3JmaWVsZC9zcmMvanMvQTExeWNvbG9yLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBOzs7Ozs7Ozs7Ozs7QUFZQSxJQUFJLHVCQUF1QixRQUFRLHdCQUFSLENBQTNCOztBQUVBLENBQUMsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QixTQUE5QixFQUF5QztBQUN4QyxNQUFJLGFBQWEsZ0JBQWpCO0FBQ0EsTUFBSSxXQUFXLEVBQWY7O0FBRUE7QUFDQSxXQUFTLE1BQVQsQ0FBZ0IsT0FBaEIsRUFBeUIsT0FBekIsRUFBa0M7QUFDaEMsU0FBSyxPQUFMLEdBQWUsT0FBZjs7QUFFQSxTQUFLLE9BQUwsR0FBZSxFQUFFLE1BQUYsQ0FBUyxFQUFULEVBQWEsUUFBYixFQUF1QixPQUF2QixDQUFmOztBQUVBLFNBQUssU0FBTCxHQUFpQixRQUFqQjtBQUNBLFNBQUssS0FBTCxHQUFhLFVBQWI7O0FBRUEsU0FBSyxJQUFMO0FBQ0Q7O0FBRUQsU0FBTyxTQUFQLEdBQW1CO0FBQ2pCLFVBQU0sVUFBUyxFQUFULEVBQWE7QUFDakIsVUFBSSxRQUFRLElBQVo7O0FBRUEsV0FBSyxvQkFBTCxHQUE0QixJQUFJLG9CQUFKLEVBQTVCOztBQUVBLFFBQUUsWUFBVztBQUNYLFlBQUksdUJBQXVCLEVBQUUsTUFBTSxPQUFSLENBQTNCOztBQUVBLGNBQU0sV0FBTixHQUFvQixxQkFBcUIsSUFBckIsQ0FDbEIsbUJBQW1CLE1BQU0sT0FBTixDQUFjLEVBQWpDLEdBQXNDLEtBRHBCLENBQXBCOztBQUlBO0FBQ0E7QUFDQTtBQUNBLDZCQUFxQixFQUFyQixDQUNFLE9BREYsRUFFRSxPQUZGLEVBR0UsRUFBRSxLQUFGLENBQVEsTUFBTSxtQkFBZCxFQUFtQyxLQUFuQyxDQUhGO0FBS0QsT0FmRDtBQWdCRCxLQXRCZ0I7O0FBd0JqQix5QkFBcUIsVUFBUyxLQUFULEVBQWdCO0FBQ25DLFVBQUksZ0JBQWdCLEtBQUssT0FBTCxDQUFhLGFBQWpDO0FBQ0EsVUFBSSxhQUFhLE1BQU0sYUFBTixDQUFvQixLQUFyQztBQUNBLFVBQUksV0FBVyxLQUFLLE9BQUwsQ0FBYSxRQUFiLEtBQTBCLE9BQTFCLEdBQW9DLEVBQXBDLEdBQXlDLEVBQXhEOztBQUVBO0FBQ0EsVUFBSSxLQUFLLG9CQUFMLENBQTBCLGdCQUExQixDQUEyQyxVQUEzQyxDQUFKLEVBQTREO0FBQzFEO0FBQ0EsWUFBSSxLQUFLLEtBQUssb0JBQUwsQ0FBMEIsY0FBMUIsQ0FDUCxhQURPLENBQVQsQ0FGMEQsQ0FJdkQ7QUFDSCxZQUFJLEtBQUssS0FBSyxvQkFBTCxDQUEwQixjQUExQixDQUNQLFVBRE8sQ0FBVCxDQUwwRCxDQU92RDtBQUNILFlBQUksZ0JBQWdCLEtBQUssb0JBQUwsQ0FBMEIsZ0JBQTFCLENBQTJDLEVBQTNDLEVBQStDLEVBQS9DLENBQXBCO0FBQ0E7QUFDQSxnQkFBUSxHQUFSLENBQ0UsS0FBSyxvQkFBTCxDQUEwQixLQUExQixDQUFnQyxhQUFoQyxFQUErQyxVQUEvQyxFQUEyRCxRQUEzRCxDQURGO0FBR0QsT0FiRCxNQWFPO0FBQ0wsZ0JBQVEsR0FBUixDQUFZLGFBQVo7QUFDRDtBQUNGO0FBOUNnQixHQUFuQjs7QUFpREE7QUFDQTtBQUNBLElBQUUsRUFBRixDQUFLLFVBQUwsSUFBbUIsVUFBUyxPQUFULEVBQWtCO0FBQ25DLFdBQU8sS0FBSyxJQUFMLENBQVUsWUFBVztBQUMxQixVQUFJLENBQUMsRUFBRSxJQUFGLENBQU8sSUFBUCxFQUFhLFlBQVksVUFBekIsQ0FBTCxFQUEyQztBQUN6QyxVQUFFLElBQUYsQ0FBTyxJQUFQLEVBQWEsWUFBWSxVQUF6QixFQUFxQyxJQUFJLE1BQUosQ0FBVyxJQUFYLEVBQWlCLE9BQWpCLENBQXJDO0FBQ0Q7QUFDRixLQUpNLENBQVA7QUFLRCxHQU5EO0FBT0QsQ0ExRUQsRUEwRUcsTUExRUgsRUEwRVcsTUExRVgsRUEwRW1CLFFBMUVuQiIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKiB2aW06IGV0OnRzPTQ6c3c9NDpzdHM9NFxuICogQGxpY2Vuc2UgYW1kZWZpbmUgMS4wLjEgQ29weXJpZ2h0IChjKSAyMDExLTIwMTYsIFRoZSBEb2pvIEZvdW5kYXRpb24gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIEF2YWlsYWJsZSB2aWEgdGhlIE1JVCBvciBuZXcgQlNEIGxpY2Vuc2UuXG4gKiBzZWU6IGh0dHA6Ly9naXRodWIuY29tL2pyYnVya2UvYW1kZWZpbmUgZm9yIGRldGFpbHNcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHByb2Nlc3MgKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmaW5lIGZvciBub2RlLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSB0aGUgXCJtb2R1bGVcIiBvYmplY3QgdGhhdCBpcyBkZWZpbmVkIGJ5IE5vZGUgZm9yIHRoZVxuICogY3VycmVudCBtb2R1bGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVxdWlyZUZuXS4gTm9kZSdzIHJlcXVpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZS5cbiAqIEl0IG9ubHkgbmVlZHMgdG8gYmUgcGFzc2VkIGluIE5vZGUgdmVyc2lvbnMgYmVmb3JlIDAuNSwgd2hlbiBtb2R1bGUucmVxdWlyZVxuICogZGlkIG5vdCBleGlzdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBkZWZpbmUgZnVuY3Rpb24gdGhhdCBpcyB1c2FibGUgZm9yIHRoZSBjdXJyZW50IG5vZGVcbiAqIG1vZHVsZS5cbiAqL1xuZnVuY3Rpb24gYW1kZWZpbmUobW9kdWxlLCByZXF1aXJlRm4pIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGRlZmluZUNhY2hlID0ge30sXG4gICAgICAgIGxvYWRlckNhY2hlID0ge30sXG4gICAgICAgIGFscmVhZHlDYWxsZWQgPSBmYWxzZSxcbiAgICAgICAgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKSxcbiAgICAgICAgbWFrZVJlcXVpcmUsIHN0cmluZ1JlcXVpcmU7XG5cbiAgICAvKipcbiAgICAgKiBUcmltcyB0aGUgLiBhbmQgLi4gZnJvbSBhbiBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICAgICAqIEl0IHdpbGwga2VlcCBhIGxlYWRpbmcgcGF0aCBzZWdtZW50IGlmIGEgLi4gd2lsbCBiZWNvbWVcbiAgICAgKiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50LCB0byBoZWxwIHdpdGggbW9kdWxlIG5hbWUgbG9va3VwcyxcbiAgICAgKiB3aGljaCBhY3QgbGlrZSBwYXRocywgYnV0IGNhbiBiZSByZW1hcHBlZC4gQnV0IHRoZSBlbmQgcmVzdWx0LFxuICAgICAqIGFsbCBwYXRocyB0aGF0IHVzZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBsb29rIG5vcm1hbGl6ZWQuXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgTU9ESUZJRVMgdGhlIGlucHV0IGFycmF5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyeSB0aGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRG90cyhhcnkpIHtcbiAgICAgICAgdmFyIGksIHBhcnQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGFyeVtpXTsgaSs9IDEpIHtcbiAgICAgICAgICAgIHBhcnQgPSBhcnlbaV07XG4gICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgYXJ5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiAoYXJ5WzJdID09PSAnLi4nIHx8IGFyeVswXSA9PT0gJy4uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9FbmQgb2YgdGhlIGxpbmUuIEtlZXAgYXQgbGVhc3Qgb25lIG5vbi1kb3RcbiAgICAgICAgICAgICAgICAgICAgLy9wYXRoIHNlZ21lbnQgYXQgdGhlIGZyb250IHNvIGl0IGNhbiBiZSBtYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0bHkgdG8gZGlzay4gT3RoZXJ3aXNlLCB0aGVyZSBpcyBsaWtlbHlcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBwYXRoIG1hcHBpbmcgZm9yIGEgcGF0aCBzdGFydGluZyB3aXRoICcuLicuXG4gICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gc3RpbGwgZmFpbCwgYnV0IGNhdGNoZXMgdGhlIG1vc3QgcmVhc29uYWJsZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXMgb2YgLi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhcnkuc3BsaWNlKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lLCBiYXNlTmFtZSkge1xuICAgICAgICB2YXIgYmFzZVBhcnRzO1xuXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgLy9JZiBoYXZlIGEgYmFzZSBuYW1lLCB0cnkgdG8gbm9ybWFsaXplIGFnYWluc3QgaXQsXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgYXNzdW1lIGl0IGlzIGEgdG9wLWxldmVsIHJlcXVpcmUgdGhhdCB3aWxsXG4gICAgICAgICAgICAvL2JlIHJlbGF0aXZlIHRvIGJhc2VVcmwgaW4gdGhlIGVuZC5cbiAgICAgICAgICAgIGlmIChiYXNlTmFtZSkge1xuICAgICAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBiYXNlUGFydHMgPSBiYXNlUGFydHMuY29uY2F0KG5hbWUuc3BsaXQoJy8nKSk7XG4gICAgICAgICAgICAgICAgdHJpbURvdHMoYmFzZVBhcnRzKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZVBhcnRzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgbm9ybWFsaXplKCkgZnVuY3Rpb24gcGFzc2VkIHRvIGEgbG9hZGVyIHBsdWdpbidzXG4gICAgICogbm9ybWFsaXplIG1ldGhvZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlTm9ybWFsaXplKHJlbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMb2FkKGlkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWQodmFsdWUpIHtcbiAgICAgICAgICAgIGxvYWRlckNhY2hlW2lkXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZC5mcm9tVGV4dCA9IGZ1bmN0aW9uIChpZCwgdGV4dCkge1xuICAgICAgICAgICAgLy9UaGlzIG9uZSBpcyBkaWZmaWN1bHQgYmVjYXVzZSB0aGUgdGV4dCBjYW4vcHJvYmFibHkgdXNlc1xuICAgICAgICAgICAgLy9kZWZpbmUsIGFuZCBhbnkgcmVsYXRpdmUgcGF0aHMgYW5kIHJlcXVpcmVzIHNob3VsZCBiZSByZWxhdGl2ZVxuICAgICAgICAgICAgLy90byB0aGF0IGlkIHdhcyBpdCB3b3VsZCBiZSBmb3VuZCBvbiBkaXNrLiBCdXQgdGhpcyB3b3VsZCByZXF1aXJlXG4gICAgICAgICAgICAvL2Jvb3RzdHJhcHBpbmcgYSBtb2R1bGUvcmVxdWlyZSBmYWlybHkgZGVlcGx5IGZyb20gbm9kZSBjb3JlLlxuICAgICAgICAgICAgLy9Ob3Qgc3VyZSBob3cgYmVzdCB0byBnbyBhYm91dCB0aGF0IHlldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYW1kZWZpbmUgZG9lcyBub3QgaW1wbGVtZW50IGxvYWQuZnJvbVRleHQnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbG9hZDtcbiAgICB9XG5cbiAgICBtYWtlUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIHJlbElkKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFtZFJlcXVpcmUoZGVwcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1N5bmNocm9ub3VzLCBzaW5nbGUgbW9kdWxlIHJlcXVpcmUoJycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1JlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCBkZXBzLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vQXJyYXkgb2YgZGVwZW5kZW5jaWVzIHdpdGggYSBjYWxsYmFjay5cblxuICAgICAgICAgICAgICAgIC8vQ29udmVydCB0aGUgZGVwZW5kZW5jaWVzIHRvIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgZGVwTmFtZSwgcmVsSWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9XYWl0IGZvciBuZXh0IHRpY2sgdG8gY2FsbCBiYWNrIHRoZSByZXF1aXJlIGNhbGwuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgZGVwcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFtZFJlcXVpcmUudG9VcmwgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgICAgIGlmIChmaWxlUGF0aC5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKGZpbGVQYXRoLCBwYXRoLmRpcm5hbWUobW9kdWxlLmZpbGVuYW1lKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYW1kUmVxdWlyZTtcbiAgICB9O1xuXG4gICAgLy9GYXZvciBleHBsaWNpdCB2YWx1ZSwgcGFzc2VkIGluIGlmIHRoZSBtb2R1bGUgd2FudHMgdG8gc3VwcG9ydCBOb2RlIDAuNC5cbiAgICByZXF1aXJlRm4gPSByZXF1aXJlRm4gfHwgZnVuY3Rpb24gcmVxKCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLnJlcXVpcmUuYXBwbHkobW9kdWxlLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBydW5GYWN0b3J5KGlkLCBkZXBzLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciByLCBlLCBtLCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBlID0gbG9hZGVyQ2FjaGVbaWRdID0ge307XG4gICAgICAgICAgICBtID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB1cmk6IF9fZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0czogZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIgPSBtYWtlUmVxdWlyZShyZXF1aXJlRm4sIGUsIG0sIGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vT25seSBzdXBwb3J0IG9uZSBkZWZpbmUgY2FsbCBwZXIgZmlsZVxuICAgICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FtZGVmaW5lIHdpdGggbm8gbW9kdWxlIElEIGNhbm5vdCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGZpbGUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy9Vc2UgdGhlIHJlYWwgdmFyaWFibGVzIGZyb20gbm9kZVxuICAgICAgICAgICAgLy9Vc2UgbW9kdWxlLmV4cG9ydHMgZm9yIGV4cG9ydHMsIHNpbmNlXG4gICAgICAgICAgICAvL3RoZSBleHBvcnRzIGluIGhlcmUgaXMgYW1kZWZpbmUgZXhwb3J0cy5cbiAgICAgICAgICAgIGUgPSBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgICAgIG0gPSBtb2R1bGU7XG4gICAgICAgICAgICByID0gbWFrZVJlcXVpcmUocmVxdWlyZUZuLCBlLCBtLCBtb2R1bGUuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9JZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzLCB0aGV5IGFyZSBzdHJpbmdzLCBzbyBuZWVkXG4gICAgICAgIC8vdG8gY29udmVydCB0aGVtIHRvIGRlcGVuZGVuY3kgdmFsdWVzLlxuICAgICAgICBpZiAoZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIoZGVwTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vQ2FsbCB0aGUgZmFjdG9yeSB3aXRoIHRoZSByaWdodCBkZXBlbmRlbmNpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeS5hcHBseShtLmV4cG9ydHMsIGRlcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFjdG9yeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbS5leHBvcnRzID0gcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVyQ2FjaGVbaWRdID0gbS5leHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RyaW5nUmVxdWlyZSA9IGZ1bmN0aW9uIChzeXN0ZW1SZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUsIGlkLCByZWxJZCkge1xuICAgICAgICAvL1NwbGl0IHRoZSBJRCBieSBhICEgc28gdGhhdFxuICAgICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKCchJyksXG4gICAgICAgICAgICBvcmlnaW5hbElkID0gaWQsXG4gICAgICAgICAgICBwcmVmaXgsIHBsdWdpbjtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuXG4gICAgICAgICAgICAvL1N0cmFpZ2h0IG1vZHVsZSBsb29rdXAuIElmIGl0IGlzIG9uZSBvZiB0aGUgc3BlY2lhbCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBpdCwgb3RoZXJ3aXNlLCBkZWxlZ2F0ZSB0byBub2RlLlxuICAgICAgICAgICAgaWYgKGlkID09PSAncmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVJlcXVpcmUoc3lzdGVtUmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlLCByZWxJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkID09PSAnZXhwb3J0cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdtb2R1bGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9hZGVyQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcnVuRmFjdG9yeS5hcHBseShudWxsLCBkZWZpbmVDYWNoZVtpZF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmKHN5c3RlbVJlcXVpcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5c3RlbVJlcXVpcmUob3JpZ2luYWxJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBtb2R1bGUgd2l0aCBJRDogJyArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIGEgcGx1Z2luIGluIHBsYXkuXG4gICAgICAgICAgICBwcmVmaXggPSBpZC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHJpbmcoaW5kZXggKyAxLCBpZC5sZW5ndGgpO1xuXG4gICAgICAgICAgICBwbHVnaW4gPSBzdHJpbmdSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcHJlZml4LCByZWxJZCk7XG5cbiAgICAgICAgICAgIGlmIChwbHVnaW4ubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBwbHVnaW4ubm9ybWFsaXplKGlkLCBtYWtlTm9ybWFsaXplKHJlbElkKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vTm9ybWFsaXplIHRoZSBJRCBub3JtYWxseS5cbiAgICAgICAgICAgICAgICBpZCA9IG5vcm1hbGl6ZShpZCwgcmVsSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG9hZGVyQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlckNhY2hlW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmxvYWQoaWQsIG1ha2VSZXF1aXJlKHN5c3RlbVJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSwgcmVsSWQpLCBtYWtlTG9hZChpZCksIHt9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9DcmVhdGUgYSBkZWZpbmUgZnVuY3Rpb24gc3BlY2lmaWMgdG8gdGhlIG1vZHVsZSBhc2tpbmcgZm9yIGFtZGVmaW5lLlxuICAgIGZ1bmN0aW9uIGRlZmluZShpZCwgZGVwcywgZmFjdG9yeSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IGlkO1xuICAgICAgICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmFjdG9yeSA9IGlkO1xuICAgICAgICAgICAgaWQgPSBkZXBzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlcHMgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBkZXBzO1xuICAgICAgICAgICAgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVwcykge1xuICAgICAgICAgICAgZGVwcyA9IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9TZXQgdXAgcHJvcGVydGllcyBmb3IgdGhpcyBtb2R1bGUuIElmIGFuIElELCB0aGVuIHVzZVxuICAgICAgICAvL2ludGVybmFsIGNhY2hlLiBJZiBubyBJRCwgdGhlbiB1c2UgdGhlIGV4dGVybmFsIHZhcmlhYmxlc1xuICAgICAgICAvL2ZvciB0aGlzIG5vZGUgbW9kdWxlLlxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIC8vUHV0IHRoZSBtb2R1bGUgaW4gZGVlcCBmcmVlemUgdW50aWwgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy9yZXF1aXJlIGNhbGwgZm9yIGl0LlxuICAgICAgICAgICAgZGVmaW5lQ2FjaGVbaWRdID0gW2lkLCBkZXBzLCBmYWN0b3J5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJ1bkZhY3RvcnkoaWQsIGRlcHMsIGZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9kZWZpbmUucmVxdWlyZSwgd2hpY2ggaGFzIGFjY2VzcyB0byBhbGwgdGhlIHZhbHVlcyBpbiB0aGVcbiAgICAvL2NhY2hlLiBVc2VmdWwgZm9yIEFNRCBtb2R1bGVzIHRoYXQgYWxsIGhhdmUgSURzIGluIHRoZSBmaWxlLFxuICAgIC8vYnV0IG5lZWQgdG8gZmluYWxseSBleHBvcnQgYSB2YWx1ZSB0byBub2RlIGJhc2VkIG9uIG9uZSBvZiB0aG9zZVxuICAgIC8vSURzLlxuICAgIGRlZmluZS5yZXF1aXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChsb2FkZXJDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZXJDYWNoZVtpZF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5lQ2FjaGVbaWRdKSB7XG4gICAgICAgICAgICBydW5GYWN0b3J5LmFwcGx5KG51bGwsIGRlZmluZUNhY2hlW2lkXSk7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyQ2FjaGVbaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRlZmluZS5hbWQgPSB7fTtcblxuICAgIHJldHVybiBkZWZpbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYW1kZWZpbmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29sb3IgQ29udGFzdCBDaGVja2VyXG4gKiBBbiBhY2Nlc3NpYmlsaXR5IGNoZWNrZXIgdG9vbCBmb3IgdmFsaWRhdGluZyB0aGUgY29sb3IgY29udHJhc3QgYmFzZWQgb24gV0NBRyAyLjAgc3RhbmRhcmQuXG4gKiB2YXIgY2NjID0gbmV3IENvbG9yQ29udHJhc3RDaGVja2VyKCk7XG5cbiAqIHZhciBjb2xvcjEgPSBcIiNGRkZGRkZcIjtcbiAqIHZhciBjb2xvcjIgPSBcIiMwMDAwMDA7XG5cbiAqIGlmIChjY2MuaXNMZXZlbEFBKGNvbG9yMSwgY29sb3IyLCAxNCkpIHtcbiAqICAgICBhbGVydChcIlZhbGlkIExldmVsIEFBXCIpO1xuICogfSBlbHNlIHtcbiAqICAgICBhbGVydChcIkludmFsaWQgQ29udHJhc3RcIik7XG4gKiB9XG4gKi9cblxudmFyIGFtZGVmaW5lID0gZmFsc2U7XG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpLFxuICAgICAgICBhbWRlZmluZSA9IHRydWU7XG5cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgICB2YXIgQ29sb3JDb250cmFzdENoZWNrZXIgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgQ29sb3JDb250cmFzdENoZWNrZXIucHJvdG90eXBlID0ge1xuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIHJnYkNsYXNzIDoge1xuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnPHI6ICcgKyB0aGlzLnIgK1xuICAgICAgICAgICAgICAgICAgICAnIGc6ICcgKyB0aGlzLmcgK1xuICAgICAgICAgICAgICAgICAgICAnIGI6ICcgKyB0aGlzLmIgK1xuICAgICAgICAgICAgICAgICAgICAnID4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkU2l4RGlnaXRDb2xvckNvZGU6IGZ1bmN0aW9uIChoZXgpe1xuICAgICAgICAgICAgdmFyIHJlZ1NpeERpZ2l0Q29sb3Jjb2RlID0gL14oIyk/KFswLTlhLWZBLUZdezZ9KShbMC05YS1mQS1GXXs2fSk/JC87XG4gICAgICAgICAgICByZXR1cm4gcmVnU2l4RGlnaXRDb2xvcmNvZGUudGVzdChoZXgpO1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkVGhyZWVEaWdpdENvbG9yQ29kZTogZnVuY3Rpb24gKGhleCl7XG4gICAgICAgICAgICB2YXIgcmVnVGhyZWVEaWdpdENvbG9yY29kZSA9IC9eKCMpPyhbMC05YS1mQS1GXXszfSkoWzAtOWEtZkEtRl17M30pPyQvO1xuICAgICAgICAgICAgcmV0dXJuIHJlZ1RocmVlRGlnaXRDb2xvcmNvZGUudGVzdChoZXgpO1xuICAgICAgICB9LFxuICAgICAgICBpc1ZhbGlkQ29sb3JDb2RlIDogZnVuY3Rpb24gKGhleCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU2l4RGlnaXRDb2xvckNvZGUoaGV4KSB8fCB0aGlzLmlzVmFsaWRUaHJlZURpZ2l0Q29sb3JDb2RlKGhleCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRDb2xvclRvU2l4RGlnaXQ6IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgICByZXR1cm4gJyMnICsgaGV4WzFdICsgaGV4WzFdICsgaGV4WzJdICsgaGV4WzJdICsgaGV4WzNdICsgaGV4WzNdO1xuICAgICAgICB9LFxuICAgICAgICBoZXhUb0x1bWluYW5jZTogZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZENvbG9yQ29kZShjb2xvcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENvbG9yIDpcIiArIGNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFRocmVlRGlnaXRDb2xvckNvZGUoY29sb3IpKSB7XG4gICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5jb252ZXJ0Q29sb3JUb1NpeERpZ2l0KGNvbG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sb3IgPSB0aGlzLmdldFJHQkZyb21IZXgoY29sb3IpO1xuXG4gICAgICAgICAgICB2YXIgTFJHQiA9IHRoaXMuY2FsY3VsYXRlTFJHQihjb2xvcik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUx1bWluYW5jZShMUkdCKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChjb2xvckEsIGNvbG9yQiwgZm9udFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9udFNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighY29sb3JBIHx8ICFjb2xvckIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsMSA9IHRoaXMuaGV4VG9MdW1pbmFuY2UoY29sb3JBKTsgLyogaGlnaGVyIHZhbHVlICovXG4gICAgICAgICAgICB2YXIgbDIgPSB0aGlzLmhleFRvTHVtaW5hbmNlKGNvbG9yQik7IC8qIGxvd2VyIHZhbHVlICovXG4gICAgICAgICAgICB2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuZ2V0Q29udHJhc3RSYXRpbyhsMSwgbDIpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlDb250cmFzdFJhdGlvKGNvbnRyYXN0UmF0aW8pO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja1BhaXJzOiBmdW5jdGlvbiAocGFpcnMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcGFpcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFpci5mb250U2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmNvbG9yQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmNvbG9yQixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmZvbnRTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmNvbG9yQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWlyLmNvbG9yQlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9LFxuICAgICAgICBjYWxjdWxhdGVMdW1pbmFuY2U6IGZ1bmN0aW9uKGxSR0IpIHtcbiAgICAgICAgICAgIHJldHVybiAoMC4yMTI2ICogbFJHQi5yKSArICgwLjcxNTIgKiBsUkdCLmcpICsgKDAuMDcyMiAqIGxSR0IuYik7XG4gICAgICAgIH0sXG4gICAgICAgIGlzTGV2ZWxBQSA6IGZ1bmN0aW9uKGNvbG9yQSwgY29sb3JCLCBmb250U2l6ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2soY29sb3JBLCBjb2xvckIsIGZvbnRTaXplKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuV0NBR19BQTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNMZXZlbEFBQSA6IGZ1bmN0aW9uKGNvbG9yQSwgY29sb3JCLCBmb250U2l6ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2soY29sb3JBLCBjb2xvckIsIGZvbnRTaXplKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuV0NBR19BQUE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJHQkZyb21IZXggOiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgICAgICAgICB2YXIgcmdiID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnJnYkNsYXNzKSxcbiAgICAgICAgICAgICAgICByVmFsLFxuICAgICAgICAgICAgICAgIGdWYWwsXG4gICAgICAgICAgICAgICAgYlZhbDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgdXNlIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByVmFsID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSwgMyksIDE2KTtcbiAgICAgICAgICAgIGdWYWwgPSBwYXJzZUludChjb2xvci5zbGljZSgzLCA1KSwgMTYpO1xuICAgICAgICAgICAgYlZhbCA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDUsIDcpLCAxNik7XG5cbiAgICAgICAgICAgIHJnYi5yID0gclZhbDtcbiAgICAgICAgICAgIHJnYi5nID0gZ1ZhbDtcbiAgICAgICAgICAgIHJnYi5iID0gYlZhbDtcblxuICAgICAgICAgICAgcmV0dXJuIHJnYjtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY3VsYXRlU1JHQiA6IGZ1bmN0aW9uKHJnYikge1xuICAgICAgICAgICAgdmFyIHNSR0IgPSBPYmplY3QuY3JlYXRlKHRoaXMucmdiQ2xhc3MpLFxuICAgICAgICAgICAgICAgIGtleTtcblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gcmdiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJnYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNSR0Jba2V5XSA9IHBhcnNlRmxvYXQoKHJnYltrZXldIC8gMjU1KSwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNSR0I7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZUxSR0I6IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgICAgICAgIHZhciBzUkdCID0gdGhpcy5jYWxjdWxhdGVTUkdCKHJnYik7XG4gICAgICAgICAgICB2YXIgbFJHQiA9IE9iamVjdC5jcmVhdGUodGhpcy5yZ2JDbGFzcyksXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbCA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIHNSR0IpIHtcbiAgICAgICAgICAgICAgICBpZiAoc1JHQi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoc1JHQltrZXldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPD0gMC4wMzkyOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbFJHQltrZXldID0gKHZhbCAvIDEyLjkyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxSR0Jba2V5XSA9IE1hdGgucG93KCgodmFsICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbFJHQjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29udHJhc3RSYXRpbyA6IGZ1bmN0aW9uKGx1bUEsIGx1bUIpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyxcbiAgICAgICAgICAgICAgICBsaWdodGVyLFxuICAgICAgICAgICAgICAgIGRhcmtlcjtcblxuICAgICAgICAgICAgaWYgKGx1bUEgPj0gbHVtQikge1xuICAgICAgICAgICAgICAgIGxpZ2h0ZXIgPSBsdW1BO1xuICAgICAgICAgICAgICAgIGRhcmtlciA9IGx1bUI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpZ2h0ZXIgPSBsdW1CO1xuICAgICAgICAgICAgICAgIGRhcmtlciA9IGx1bUE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhdGlvID0gKGxpZ2h0ZXIgKyAwLjA1KSAvIChkYXJrZXIgKyAwLjA1KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xuICAgICAgICB9LFxuICAgICAgICB2ZXJpZnlDb250cmFzdFJhdGlvIDogZnVuY3Rpb24ocmF0aW8pIHtcblxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0c0NsYXNzID0ge1xuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8IFdDQUctQUE6ICcgKyAoKHRoaXMuV0NBR19BQSkgPyAncGFzcycgOiAnZmFpbCcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgV0NBRy1BQUE6ICcgKyAoKHRoaXMuV0NBR19BQUEpID8gJ3Bhc3MnIDogJ2ZhaWwnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnID4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgV0NBR19SRVFfUkFUSU9fQUFfTEcgPSAzLjAsXG4gICAgICAgICAgICAgICAgV0NBR19SRVFfUkFUSU9fQUFfU00gPSA0LjUsXG4gICAgICAgICAgICAgICAgV0NBR19SRVFfUkFUSU9fQUFBX0xHID0gNC41LFxuICAgICAgICAgICAgICAgIFdDQUdfUkVRX1JBVElPX0FBQV9TTSA9IDcuMCxcbiAgICAgICAgICAgICAgICBXQ0FHX0ZPTlRfQ1VUT0ZGID0gMTg7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gT2JqZWN0LmNyZWF0ZShyZXN1bHRzQ2xhc3MpLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSB8fCAxNDtcblxuICAgICAgICAgICAgaWYgKGZvbnRTaXplID49IFdDQUdfRk9OVF9DVVRPRkYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLldDQUdfQUEgPSAocmF0aW8gPj0gV0NBR19SRVFfUkFUSU9fQUFfTEcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuV0NBR19BQUEgPSAocmF0aW8gPj0gV0NBR19SRVFfUkFUSU9fQUFBX0xHKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5XQ0FHX0FBID0gKHJhdGlvID49IFdDQUdfUkVRX1JBVElPX0FBX1NNKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLldDQUdfQUFBID0gKHJhdGlvID49IFdDQUdfUkVRX1JBVElPX0FBQV9TTSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbG9yQ29udHJhc3RDaGVja2VyO1xufSk7XG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQTExeSBjb2xvciBmaWVsZHR5cGUgcGx1Z2luIGZvciBDcmFmdCBDTVNcbiAqXG4gKiBBMTF5Y29sb3IgRmllbGQgSlNcbiAqXG4gKiBAYXV0aG9yICAgIElhaW4gQmVhblxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTggSWFpbiBCZWFuXG4gKiBAbGluayAgICAgIGh0dHBzOi8vaWFpbmJlYW4uY29tXG4gKiBAcGFja2FnZSAgIEExMXlDb2xvckZpZWxkdHlwZVxuICogQHNpbmNlICAgICAxLjAuMEExMXlDb2xvckZpZWxkdHlwZUExMXljb2xvclxuICovXG5cbnZhciBDb2xvckNvbnRyYXN0Q2hlY2tlciA9IHJlcXVpcmUoJ2NvbG9yLWNvbnRyYXN0LWNoZWNrZXInKTtcblxuKGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuICB2YXIgcGx1Z2luTmFtZSA9ICdBMTF5Q29sb3JGaWVsZCc7XG4gIHZhciBkZWZhdWx0cyA9IHt9O1xuXG4gIC8vIFBsdWdpbiBjb25zdHJ1Y3RvclxuICBmdW5jdGlvbiBQbHVnaW4oZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICB0aGlzLl9uYW1lID0gcGx1Z2luTmFtZTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgUGx1Z2luLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5jb2xvckNvbnRyYXN0Q2hlY2tlciA9IG5ldyBDb2xvckNvbnRyYXN0Q2hlY2tlcigpO1xuXG4gICAgICAkKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgJGNvbG9yRmllbGRDb250YWluZXIgPSAkKF90aGlzLmVsZW1lbnQpO1xuXG4gICAgICAgIF90aGlzLiRjb2xvckZpZWxkID0gJGNvbG9yRmllbGRDb250YWluZXIuZmluZChcbiAgICAgICAgICAnW25hbWU9XCJmaWVsZHNbJyArIF90aGlzLm9wdGlvbnMuaWQgKyAnXVwiXSdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIGlucHV0IGV2ZW50cyBvbiBhbnkgaW5wdXQgaW4gdGhlIGNvbnRhaW5lcjpcbiAgICAgICAgLy8gVGhpcyBpcyBlaXRoZXIgdGhlIDxpbnB1dCB0eXBlPVwiY29sb3JcIj4gb3IgdGhlIDxpbnB1dCB0eXBlPVwidGV4dFwiPlxuICAgICAgICAvLyBuZXh0IHRvIGl0XG4gICAgICAgICRjb2xvckZpZWxkQ29udGFpbmVyLm9uKFxuICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAkLnByb3h5KF90aGlzLnVwZGF0ZUNvbG9yQ29udHJhc3QsIF90aGlzKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUNvbG9yQ29udHJhc3Q6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgY29udHJhc3RDb2xvciA9IHRoaXMub3B0aW9ucy5jb250cmFzdENvbG9yO1xuICAgICAgdmFyIGZpZWxkQ29sb3IgPSBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlO1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnRTaXplID09PSAnbGFyZ2UnID8gMjIgOiAxNDtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHZhbGlkIDMgb3IgNiBjaGFyYWN0ZXIgaGV4IGNvZGVcbiAgICAgIGlmICh0aGlzLmNvbG9yQ29udHJhc3RDaGVja2VyLmlzVmFsaWRDb2xvckNvZGUoZmllbGRDb2xvcikpIHtcbiAgICAgICAgLy8gR2V0IHRoZSByYXRpb1xuICAgICAgICB2YXIgbDEgPSB0aGlzLmNvbG9yQ29udHJhc3RDaGVja2VyLmhleFRvTHVtaW5hbmNlKFxuICAgICAgICAgIGNvbnRyYXN0Q29sb3JcbiAgICAgICAgKTsgLyogaGlnaGVyIHZhbHVlICovXG4gICAgICAgIHZhciBsMiA9IHRoaXMuY29sb3JDb250cmFzdENoZWNrZXIuaGV4VG9MdW1pbmFuY2UoXG4gICAgICAgICAgZmllbGRDb2xvclxuICAgICAgICApOyAvKiBsb3dlciB2YWx1ZSAqL1xuICAgICAgICB2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29sb3JDb250cmFzdENoZWNrZXIuZ2V0Q29udHJhc3RSYXRpbyhsMSwgbDIpO1xuICAgICAgICAvLyBJcyBpdCB2YWxpZD9cbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgdGhpcy5jb2xvckNvbnRyYXN0Q2hlY2tlci5jaGVjayhjb250cmFzdENvbG9yLCBmaWVsZENvbG9yLCBmb250U2l6ZSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIEhleCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBIHJlYWxseSBsaWdodHdlaWdodCBwbHVnaW4gd3JhcHBlciBhcm91bmQgdGhlIGNvbnN0cnVjdG9yLFxuICAvLyBwcmV2ZW50aW5nIGFnYWluc3QgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnNcbiAgJC5mbltwbHVnaW5OYW1lXSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCEkLmRhdGEodGhpcywgJ3BsdWdpbl8nICsgcGx1Z2luTmFtZSkpIHtcbiAgICAgICAgJC5kYXRhKHRoaXMsICdwbHVnaW5fJyArIHBsdWdpbk5hbWUsIG5ldyBQbHVnaW4odGhpcywgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSkoalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcbiJdfQ==\n"]}